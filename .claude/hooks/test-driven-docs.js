#!/usr/bin/env node

/**
 * Test-Driven Documentation Hook
 * 
 * Automatically updates debugging guides and documentation after fixes
 * Maintains knowledge base of solutions and creates regression tests
 */

const { execSync } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class TestDrivenDocs {
  constructor(config) {
    this.config = config;
    this.logger = this.createLogger();
    this.knowledgeBase = new Map();
  }

  createLogger() {
    return {
      info: (msg) => this.log('INFO', msg),
      warn: (msg) => this.log('WARN', msg),
      error: (msg) => this.log('ERROR', msg),
      debug: (msg) => this.log('DEBUG', msg)
    };
  }

  async log(level, message) {
    const timestamp = new Date().toISOString();
    const logMessage = `${timestamp} [${level}] ${message}`;
    console.log(logMessage);
    
    try {
      await fs.appendFile('.claude/logs/test-driven-docs.log', logMessage + '\n');
    } catch (err) {
      console.error('Failed to write to log file:', err);
    }
  }

  async run(commitInfo = null) {
    this.logger.info('Starting test-driven documentation update');
    
    // Get commit information if not provided
    if (!commitInfo) {
      commitInfo = await this.getRecentCommitInfo();
    }
    
    if (!commitInfo || !this.isBugFixCommit(commitInfo)) {
      this.logger.info('No bug fix commits found, skipping documentation update');
      return { success: true, skipped: true };
    }
    
    this.logger.info(`Processing bug fix commit: ${commitInfo.hash}`);
    
    let totalUpdates = 0;
    let successfulUpdates = 0;
    
    // Load existing knowledge base
    await this.loadKnowledgeBase();
    
    // Analyze the bug fix
    const bugAnalysis = await this.analyzeBugFix(commitInfo);
    
    if (bugAnalysis) {
      // Update debugging guide
      if (this.config.autoUpdateDocs) {
        const docUpdate = await this.updateDebuggingGuide(bugAnalysis);
        totalUpdates++;
        if (docUpdate.success) successfulUpdates++;
      }
      
      // Update changelog
      const changelogUpdate = await this.updateChangelog(bugAnalysis, commitInfo);
      totalUpdates++;
      if (changelogUpdate.success) successfulUpdates++;
      
      // Create test cases
      if (this.config.generateTestCases) {
        const testUpdate = await this.generateTestCases(bugAnalysis);
        totalUpdates++;
        if (testUpdate.success) successfulUpdates++;
      }
      
      // Update knowledge base\n      await this.updateKnowledgeBase(bugAnalysis);\n      \n      // Link commit to issue\n      if (this.config.linkCommitsToIssues) {\n        await this.linkCommitToIssue(commitInfo, bugAnalysis);\n      }\n    }\n    \n    const success = totalUpdates === 0 || successfulUpdates >= totalUpdates * 0.8;\n    \n    this.logger.info(`Documentation update complete: ${successfulUpdates}/${totalUpdates} updates successful`);\n    \n    return {\n      success,\n      totalUpdates,\n      successfulUpdates,\n      bugAnalysis\n    };\n  }\n\n  async getRecentCommitInfo() {\n    try {\n      const gitLog = execSync('git log -1 --pretty=format:\"%H|%s|%b|%an|%ad\" --date=iso', { \n        encoding: 'utf-8' \n      });\n      \n      const [hash, subject, body, author, date] = gitLog.split('|');\n      \n      const changedFiles = execSync(`git diff-tree --no-commit-id --name-only -r ${hash}`, {\n        encoding: 'utf-8'\n      }).trim().split('\\n').filter(f => f);\n      \n      return {\n        hash,\n        subject,\n        body: body || '',\n        author,\n        date,\n        changedFiles\n      };\n      \n    } catch (error) {\n      this.logger.error(`Failed to get commit info: ${error.message}`);\n      return null;\n    }\n  }\n\n  isBugFixCommit(commitInfo) {\n    const fixKeywords = ['fix', 'bug', 'error', 'issue', 'resolve', 'correct', 'repair'];\n    const subject = commitInfo.subject.toLowerCase();\n    \n    return fixKeywords.some(keyword => subject.includes(keyword));\n  }\n\n  async loadKnowledgeBase() {\n    try {\n      const kbPath = '.claude/knowledge-base.json';\n      const kbData = await fs.readFile(kbPath, 'utf-8');\n      const kb = JSON.parse(kbData);\n      \n      for (const [key, value] of Object.entries(kb)) {\n        this.knowledgeBase.set(key, value);\n      }\n      \n      this.logger.debug(`Loaded ${this.knowledgeBase.size} knowledge base entries`);\n      \n    } catch (error) {\n      this.logger.debug('No existing knowledge base found, starting fresh');\n    }\n  }\n\n  async analyzeBugFix(commitInfo) {\n    const analysis = {\n      type: this.categorizeBugFix(commitInfo),\n      description: commitInfo.subject,\n      affectedFiles: commitInfo.changedFiles,\n      solution: await this.extractSolution(commitInfo),\n      rootCause: await this.identifyRootCause(commitInfo),\n      preventionSteps: [],\n      testCases: [],\n      relatedIssues: []\n    };\n    \n    // Analyze changed files for patterns\n    for (const file of commitInfo.changedFiles) {\n      const fileAnalysis = await this.analyzeChangedFile(file, commitInfo.hash);\n      if (fileAnalysis) {\n        analysis.solution.push(...fileAnalysis.changes);\n        analysis.preventionSteps.push(...fileAnalysis.preventionSteps);\n      }\n    }\n    \n    return analysis;\n  }\n\n  categorizeBugFix(commitInfo) {\n    const subject = commitInfo.subject.toLowerCase();\n    const files = commitInfo.changedFiles;\n    \n    // UI/Visual bugs\n    if (subject.includes('visual') || subject.includes('ui') || subject.includes('style')) {\n      return 'visual';\n    }\n    \n    // Build errors\n    if (subject.includes('build') || subject.includes('compile') || subject.includes('typescript')) {\n      return 'build';\n    }\n    \n    // API/Route issues\n    if (files.some(f => f.includes('api/')) || subject.includes('api') || subject.includes('route')) {\n      return 'api';\n    }\n    \n    // Database/Data issues\n    if (subject.includes('data') || subject.includes('database') || subject.includes('firebase')) {\n      return 'data';\n    }\n    \n    // Performance issues\n    if (subject.includes('performance') || subject.includes('slow') || subject.includes('optimize')) {\n      return 'performance';\n    }\n    \n    // Layout/Routing issues\n    if (files.some(f => f.includes('layout') || f.includes('page.tsx')) || subject.includes('404')) {\n      return 'routing';\n    }\n    \n    return 'general';\n  }\n\n  async extractSolution(commitInfo) {\n    const solutions = [];\n    \n    // Extract from commit message\n    if (commitInfo.body) {\n      const bodyLines = commitInfo.body.split('\\n');\n      solutions.push(...bodyLines.filter(line => \n        line.includes('solution:') || \n        line.includes('fix:') ||\n        line.includes('resolved by:')\n      ));\n    }\n    \n    // Analyze file changes\n    for (const file of commitInfo.changedFiles) {\n      try {\n        const diff = execSync(`git show ${commitInfo.hash} -- ${file}`, { encoding: 'utf-8' });\n        const changes = this.extractMeaningfulChanges(diff);\n        solutions.push(...changes);\n      } catch (error) {\n        this.logger.debug(`Could not get diff for ${file}: ${error.message}`);\n      }\n    }\n    \n    return solutions;\n  }\n\n  extractMeaningfulChanges(diff) {\n    const changes = [];\n    const lines = diff.split('\\n');\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      // Look for added lines that seem like fixes\n      if (line.startsWith('+') && !line.startsWith('+++')) {\n        const content = line.substring(1).trim();\n        \n        // Skip empty lines and imports\n        if (content && !content.startsWith('import') && !content.startsWith('//')) {\n          // Identify common fix patterns\n          if (content.includes('escape') || \n              content.includes('NextResponse') ||\n              content.includes('try') ||\n              content.includes('catch') ||\n              content.includes('await') ||\n              content.includes('timeout')) {\n            changes.push(`Added: ${content}`);\n          }\n        }\n      }\n    }\n    \n    return changes;\n  }\n\n  async identifyRootCause(commitInfo) {\n    const subject = commitInfo.subject.toLowerCase();\n    \n    // Common root cause patterns\n    if (subject.includes('apostrophe') || subject.includes('quote')) {\n      return 'Unescaped characters in JSX';\n    }\n    \n    if (subject.includes('404') || subject.includes('not found')) {\n      return 'Routing or file resolution issue';\n    }\n    \n    if (subject.includes('type') && subject.includes('error')) {\n      return 'TypeScript type mismatch';\n    }\n    \n    if (subject.includes('build') && subject.includes('error')) {\n      return 'Build configuration or syntax error';\n    }\n    \n    if (subject.includes('env') || subject.includes('environment')) {\n      return 'Environment variable configuration';\n    }\n    \n    return 'Unknown - requires investigation';\n  }\n\n  async analyzeChangedFile(file, commitHash) {\n    try {\n      const diff = execSync(`git show ${commitHash} -- ${file}`, { encoding: 'utf-8' });\n      \n      const analysis = {\n        changes: [],\n        preventionSteps: []\n      };\n      \n      // Analyze file type and changes\n      if (file.endsWith('.tsx') || file.endsWith('.ts')) {\n        analysis.changes.push(`Modified TypeScript file: ${file}`);\n        \n        if (diff.includes('escape')) {\n          analysis.preventionSteps.push('Use ESLint rules to catch unescaped characters');\n        }\n        \n        if (diff.includes('NextResponse')) {\n          analysis.preventionSteps.push('Ensure all API routes return NextResponse objects');\n        }\n      }\n      \n      if (file.includes('layout.tsx')) {\n        analysis.preventionSteps.push('Test layout hierarchy changes thoroughly');\n      }\n      \n      return analysis;\n      \n    } catch (error) {\n      this.logger.debug(`Could not analyze file ${file}: ${error.message}`);\n      return null;\n    }\n  }\n\n  async updateDebuggingGuide(bugAnalysis) {\n    try {\n      const debugGuide = 'docs/DEBUGGING_GUIDE.md';\n      \n      // Check if file exists\n      let content = '';\n      try {\n        content = await fs.readFile(debugGuide, 'utf-8');\n      } catch {\n        // Create new debugging guide\n        content = this.createNewDebuggingGuide();\n      }\n      \n      // Add new issue section\n      const newSection = this.generateDebuggingSection(bugAnalysis);\n      \n      // Insert the new section\n      const insertIndex = content.indexOf('## 🔍 **Issue');\n      if (insertIndex > -1) {\n        // Insert after existing issues\n        const nextIssueIndex = content.indexOf('## 🔍 **Issue', insertIndex + 1);\n        const insertPoint = nextIssueIndex > -1 ? nextIssueIndex : content.indexOf('---', insertIndex);\n        \n        if (insertPoint > -1) {\n          content = content.substring(0, insertPoint) + newSection + '\\n\\n' + content.substring(insertPoint);\n        } else {\n          content += '\\n\\n' + newSection;\n        }\n      } else {\n        // Add to end of file\n        content += '\\n\\n' + newSection;\n      }\n      \n      await fs.writeFile(debugGuide, content, 'utf-8');\n      this.logger.info(`Updated debugging guide with new issue: ${bugAnalysis.type}`);\n      \n      return { success: true };\n      \n    } catch (error) {\n      this.logger.error(`Failed to update debugging guide: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  createNewDebuggingGuide() {\n    return `# Debugging Guide\n\nThis guide documents common issues and their solutions.\n\n## 🚨 **Critical Issues Encountered & Solutions**\n\nThis guide documents all the debugging challenges encountered during development and their solutions.\n`;\n  }\n\n  generateDebuggingSection(bugAnalysis) {\n    const issueNumber = Math.floor(Math.random() * 1000); // In real implementation, would use proper numbering\n    \n    return `## 🔍 **Issue #${issueNumber}: ${bugAnalysis.type.toUpperCase()} - ${bugAnalysis.description}**\n\n### **Problem**\n${bugAnalysis.description}\n\n### **Root Cause**\n${bugAnalysis.rootCause}\n\n### **Solution**\n${bugAnalysis.solution.map(s => `- ${s}`).join('\\n')}\n\n### **Prevention Steps**\n${bugAnalysis.preventionSteps.map(s => `- ${s}`).join('\\n')}\n\n### **Files Affected**\n${bugAnalysis.affectedFiles.map(f => `- ${f}`).join('\\n')}\n\n### **Date**\n${new Date().toISOString().split('T')[0]}\n\n---`;\n  }\n\n  async updateChangelog(bugAnalysis, commitInfo) {\n    try {\n      const changelog = 'docs/CHANGELOG.md';\n      \n      let content = '';\n      try {\n        content = await fs.readFile(changelog, 'utf-8');\n      } catch {\n        content = this.createNewChangelog();\n      }\n      \n      const changelogEntry = this.generateChangelogEntry(bugAnalysis, commitInfo);\n      \n      // Insert at the top after the header\n      const insertIndex = content.indexOf('\\n## ') || content.indexOf('\\n### ');\n      if (insertIndex > -1) {\n        content = content.substring(0, insertIndex) + '\\n\\n' + changelogEntry + content.substring(insertIndex);\n      } else {\n        content += '\\n\\n' + changelogEntry;\n      }\n      \n      await fs.writeFile(changelog, content, 'utf-8');\n      this.logger.info('Updated changelog with bug fix entry');\n      \n      return { success: true };\n      \n    } catch (error) {\n      this.logger.error(`Failed to update changelog: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  createNewChangelog() {\n    return `# Changelog\n\nAll notable changes to this project will be documented in this file.\n`;\n  }\n\n  generateChangelogEntry(bugAnalysis, commitInfo) {\n    const date = new Date().toISOString().split('T')[0];\n    \n    return `## ${date} - Bug Fix: ${bugAnalysis.type}\n\n### 🐛 **Fixed**\n- ${bugAnalysis.description}\n- Root cause: ${bugAnalysis.rootCause}\n- Files affected: ${bugAnalysis.affectedFiles.join(', ')}\n- Commit: ${commitInfo.hash.substring(0, 8)}`;\n  }\n\n  async generateTestCases(bugAnalysis) {\n    if (!this.config.generateTestCases) {\n      return { success: true, skipped: true };\n    }\n    \n    try {\n      const testCasesDir = '.claude/test-cases';\n      await fs.mkdir(testCasesDir, { recursive: true });\n      \n      const testCaseFile = path.join(testCasesDir, `${bugAnalysis.type}-regression.md`);\n      \n      const testCaseContent = this.generateTestCaseContent(bugAnalysis);\n      \n      await fs.writeFile(testCaseFile, testCaseContent, 'utf-8');\n      this.logger.info(`Generated test case: ${testCaseFile}`);\n      \n      return { success: true };\n      \n    } catch (error) {\n      this.logger.error(`Failed to generate test cases: ${error.message}`);\n      return { success: false, error: error.message };\n    }\n  }\n\n  generateTestCaseContent(bugAnalysis) {\n    return `# Test Case: ${bugAnalysis.type} Regression\n\n## Description\nRegression test for: ${bugAnalysis.description}\n\n## Steps to Reproduce\n1. [Add specific steps based on bug type]\n2. [Verify the issue occurs]\n3. [Apply the fix]\n4. [Verify the fix works]\n\n## Expected Result\nThe issue should not reoccur after the fix is applied.\n\n## Root Cause\n${bugAnalysis.rootCause}\n\n## Solution Applied\n${bugAnalysis.solution.join('\\n')}\n\n## Prevention\n${bugAnalysis.preventionSteps.join('\\n')}\n\n## Affected Files\n${bugAnalysis.affectedFiles.join('\\n')}\n\n## Test Date\n${new Date().toISOString()}\n`;\n  }\n\n  async updateKnowledgeBase(bugAnalysis) {\n    const key = `${bugAnalysis.type}-${Date.now()}`;\n    this.knowledgeBase.set(key, {\n      type: bugAnalysis.type,\n      description: bugAnalysis.description,\n      rootCause: bugAnalysis.rootCause,\n      solution: bugAnalysis.solution,\n      preventionSteps: bugAnalysis.preventionSteps,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Save to disk\n    try {\n      const kbPath = '.claude/knowledge-base.json';\n      const kbData = Object.fromEntries(this.knowledgeBase);\n      await fs.writeFile(kbPath, JSON.stringify(kbData, null, 2), 'utf-8');\n      this.logger.debug('Updated knowledge base');\n    } catch (error) {\n      this.logger.error(`Failed to save knowledge base: ${error.message}`);\n    }\n  }\n\n  async linkCommitToIssue(commitInfo, bugAnalysis) {\n    // This would integrate with issue tracking systems\n    // For now, just log the connection\n    this.logger.info(`Linked commit ${commitInfo.hash.substring(0, 8)} to ${bugAnalysis.type} issue`);\n  }\n}\n\n// Export for use as a module\nmodule.exports = TestDrivenDocs;\n\n// CLI usage\nif (require.main === module) {\n  const configPath = path.join(process.cwd(), '.claude/config/hooks.json');\n  \n  const loadConfig = async () => {\n    try {\n      const configData = await fs.readFile(configPath, 'utf-8');\n      const config = JSON.parse(configData);\n      return config.hooks['test-driven-docs'].config;\n    } catch (error) {\n      console.error('Failed to load config:', error.message);\n      return {\n        autoUpdateDocs: true,\n        linkCommitsToIssues: true,\n        generateTestCases: true,\n        maintainKnowledgeBase: true\n      };\n    }\n  };\n  \n  const run = async () => {\n    const config = await loadConfig();\n    const hook = new TestDrivenDocs(config);\n    \n    // Can accept commit hash as argument\n    const commitHash = process.argv[2];\n    const commitInfo = commitHash ? await hook.getCommitInfo(commitHash) : null;\n    \n    const result = await hook.run(commitInfo);\n    \n    if (!result.success && !result.skipped) {\n      console.error('Test-driven documentation update failed');\n      process.exit(1);\n    }\n    \n    console.log('Test-driven documentation completed successfully');\n  };\n  \n  run().catch(error => {\n    console.error('Hook execution failed:', error);\n    process.exit(1);\n  });\n}